---
title: 2Dæ¡Œçƒç„å‡†è¾…åŠ©å¼€å‘
date: 2020-11-25 16:33:03
tags:
---

æˆ‘å°æ—¶å€™éå¸¸å–œæ¬¢ç©QQæ¡Œçƒï¼Œæœ€è¿‘é—²æ¥æ— äº‹ï¼Œå°±æƒ³åšä¸€ä¸ªæ¡Œçƒçš„è¾…åŠ©ç„å‡†å™¨ã€‚åˆæ­¥çš„æƒ³æ³•æ˜¯ï¼Œåœ¨ä¸ç›´æ¥å¯¹æ¡Œçƒç¨‹åºåšæ‰‹è„šçš„æƒ…å†µä¸‹è¿›è¡Œå¼€å‘ï¼Œé‚£ä¹ˆè‡ªç„¶è€Œç„¶åœ°æƒ³åˆ°å…ˆå¯¹çƒå°æˆªå›¾ï¼Œåˆ©ç”¨å›¾ç‰‡è¯†åˆ«è·å–æ¯ä¸ªçƒä½ç½®ã€‚å¯¹äºçƒå°å’Œçƒæ´ï¼Œç”±äºä»–ä¿©çš„å¤§å°ã€ä½ç½®æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥ç›´æ¥æ ¹æ®æˆªå›¾æ‰‹åŠ¨ç®—å‡ºçƒå°å¤§å°ã€çƒæ´åæ ‡ã€‚

ä¹‹åæ ¹æ®è¿™äº›ä¿¡æ¯ï¼Œåˆ©ç”¨ä¸€ä¸‹å‡ ä½•å…³ç³»å°±èƒ½ç®—å‡ºå‡»çƒç‚¹ï¼Œåœ¨å°†é¼ æ ‡çš„ä½ç½®è®¾ç½®åˆ°å‡»çƒç‚¹å¤„ï¼Œå°±å®Œæˆäº†ä¸€æ¬¡å‡»çƒçš„è‡ªåŠ¨ç„å‡†ã€‚ä¸‹é¢è¿›å…¥æ­£é¢˜...

<!-- more --> 

# æºç 
æœ¬æ–‡ç›¸å…³ä»£ç é“¾æ¥ï¼šğŸ”—[Billiard_Helper](https://github.com/L-Sun/billiard_helper)

# ç¼–ç¨‹ç¯å¢ƒå‡†å¤‡
ç”±äºæ­¤å‰ä¸€ç›´åœ¨ç”¨VSCodeè¿›è¡ŒC++å¼€å‘ï¼Œæ‰€ä»¥æ¯”è¾ƒåŸºç¡€çš„ç¯å¢ƒæ­å»ºå¹¶ä¸åœ¨è¿™é˜è¿°ï¼Œä»¥åæœ‰ç©ºä¼šå‘ä¸€ç¯‡æ¯”è¾ƒå…¨é¢çš„æ•™ç¨‹æ–‡ã€‚

## OpenCVå®‰è£…
åœ¨Windowsä¸‹çš„C++å¼€å‘ï¼Œæˆ‘ä¸€èˆ¬æ˜¯ç”¨Vcpkgæ¥å¯¹packagesè¿›è¡Œç®¡ç†ï¼Œå¥½å¤„å°±æ˜¯çœå»æ‰‹åŠ¨åˆ°packageæ‰€åœ¨çš„å®˜ç½‘ä¸‹è½½æºç ã€é…ç½®ã€ç¼–è¯‘ã€è®¾ç½®ç¯å¢ƒå˜é‡ç­‰ç­‰æ‚ä¸ƒæ‚å…«çš„äº‹é¡¹ã€‚ä½†æœ‰ç‚¹ä¸è¶³çš„æ˜¯Vcpkgä¸Šçš„packageå¹¶ä¸ä¸€å®šæ˜¯æœ€æ–°ç‰ˆæœ¬ï¼ŒåŒæ—¶Vcpkgä¸Šçš„packageç¼–è¯‘é…ç½®æ–‡ä»¶æœ‰å¯èƒ½æ˜¯ç”±ç¤¾åŒºç¼–å†™ï¼Œè€Œä¸æ˜¯packageçš„ä½œè€…æ¥ç¼–å†™ï¼Œå› æ­¤æœ‰å¯èƒ½ä¼šå‡ºç°ä¸€äº›å¥‡æ€ªçš„é—®é¢˜ã€‚ä½†æˆ‘ä»¬è¿™é‡Œè¦ç”¨OpenCVï¼Œæ˜¾ç„¶è¿™ç§çƒ­é—¨çš„é¡¹ç›®ä¸€èˆ¬æ˜¯ç»å¾—ä½è€ƒéªŒçš„ã€‚å®‰è£…OpenCVå‘½ä»¤å¦‚ä¸‹ï¼Œå¦‚æœæ²¡æœ‰æ¢¯å­ï¼Œä¸‹è½½å¾ˆæœ‰å¯èƒ½ä¼šå› ä¸ºå¢™çš„åŸå› è€Œå¡ä½ã€‚

```
cd vcpkg
git pull
vcpkg.exe install opencv:x64-windows
```

## VScodeä¸‹é¡¹ç›®ç›®å½•è®¾ç½®
é¦–å…ˆåˆ›å»ºä¸€ä¸ªé¡¹ç›®çš„æ–‡ä»¶å¤¹
```
mkdir billiard_helper
# ä½¿ç”¨VScodeæ‰“å¼€æ–‡ä»¶å¤¹
code billiard_helper
```
åœ¨è¿›è¡Œå®é™…ç¼–ç å‰ï¼Œè¿˜è¦é…ç½®ä¸€äº›ä¸œè¥¿ï¼Œæ–¹ä¾¿ä¹‹åçš„è°ƒè¯•ã€‚åœ¨é¡¹ç›®æ–‡ä»¶å¤¹ä¸‹ï¼Œæ–°å»ºä¸€ä¸ªæ–‡ä»¶`./.vscode/settings.json`ï¼Œå¹¶ä¸ºCMake Toolsæ’ä»¶æ·»åŠ ä¸€æ¡é…ç½®é¡¹
```json
{
        "cmake.configureArgs": [
        "-DCMAKE_TOOLCHAIN_FILE=E:/workspace/vcpkg/scripts/buildsystems/vcpkg.cmake"
    ]
}
```
ä½œç”¨æ˜¯å°†Vcpkgç®¡ç†åŒ…çš„ä¿¡æ¯ç»™åˆ°CMakeï¼Œæ–¹ä¾¿CMakeæŸ¥æ‰¾packagesã€‚

åœ¨VSCodeæŒ‰ä¸‹<kbd>F5</kbd>ï¼Œä¹‹åé€‰æ‹©C++ï¼Œåœ¨`.vscode`ä¸‹ä¼šå‡ºç°æ–°çš„ä¸€ä¸ªæ–‡ä»¶`launch.json`ï¼Œå°†`"program"`çš„å€¼ä¿®æ”¹ä¸º`"${command:cmake.launchTargetPath}"`ï¼Œä¹‹åå°±å¯ä»¥é€šè¿‡CMake Toolsæ’ä»¶æ¥ç¼–è¯‘è¿è¡Œ

## CMakeLists.txt
åœ¨ç›®å½•ä¸‹åˆ›å»ºCMakeLists.txtï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨åˆ°OpenCVï¼Œæ‰€ä»¥åœ¨ç¬¬6è¡Œä¸­è¡¨æ˜éœ€è¦æ‰¾åˆ°OpenCVï¼Œä¸”åªè¦å…¶ä¸­ä¸¤ä¸ªæ¨¡å—
```cmake
make_minimum_required(VERSION 3.15.0)
project(billiard_helper VERSION 1.0.0)

set(CMAKE_CXX_STANDARD 20)

find_package(OpenCV REQUIRED COMPONENTS core imgcodecs)
```
å®Œæˆä¹‹åï¼Œå°±å¯ä»¥æ­£å¼è¿›å…¥ç ä»£ç çš„ç¯å¢ƒäº†ã€‚

# ä»£ç éƒ¨åˆ†
åœ¨æ•²ä»£ç å‰ï¼Œè¦å…ˆæ˜ç¡®éœ€æ±‚ï¼Œåˆ†è§£éœ€æ±‚ã€‚è„‘å­é‡Œçš„ç¬¬ä¸€æƒ³æ³•æ˜¯ï¼Œè®©ç¨‹åºå¸®æˆ‘ç„å‡†æ¡Œçƒã€‚ç„å‡†æ¡Œçƒçš„åŸºæœ¬æ€æƒ³å¦‚ä¸‹
{% asset_img aiming_ghost-ball_terminology.png%}

æˆ‘ä»¬æœŸæœ›ç™½çƒå‡»æ‰“é»‘çƒåå¾€é»‘è‰²ç®­å¤´æ–¹å‘è¿åŠ¨ï¼Œé‚£ä¹ˆç™½çƒä¸é»‘çƒç¢°æ’çš„ä½ç½®å¦‚å›¾ï¼Œæ­¤æ—¶ç™½çƒçš„ä¸­å¿ƒå°±æ˜¯æˆ‘ä»¬é¼ æ ‡éœ€è¦ç„å‡†çš„ä½ç½®ã€‚å‡è®¾é»‘çƒä¸­å¿ƒä¸º$p_b$ï¼Œé»‘è‰²ç®­å¤´æ–¹å‘å•ä½å‘é‡ä¸º$\vec{v}$ï¼Œçƒçš„åŠå¾„ä¸º$r$ï¼Œåˆ™ç„å‡†ä½ç½®åº”ä¸º$p_b - r\vec{v}$ã€‚çƒçš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œå¯ä»¥å¾ˆå®¹æ˜“æµ‹å‡ºæ¥ï¼Œè€Œçƒçš„ä½ç½®æ˜¯å˜åŒ–çš„ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦çš„ä¿¡æ¯æœ‰

1. å½©çƒçš„ä½ç½®
    1. çƒå°çš„æˆªå›¾
2. å½©çƒè¿åŠ¨çš„ç›®æ ‡ç‚¹
    1. æ ¹æ®é¼ æ ‡çš„ä½ç½®ï¼Œåˆ¤æ–­éœ€è¦è¿›å“ªä¸ªçƒæ´
    2. æœ‰æ—¶éœ€è¦ä»¥çƒå‡»çƒï¼Œå› æ­¤ç›®æ ‡ç‚¹ä¸ä¸€å®šæ˜¯çƒæ´ï¼Œå› æ­¤éœ€è¦é¼ æ ‡æ¥æŒ‡å®šç›®æ ‡ç‚¹
3. çƒæ´çš„ä½ç½®ï¼ˆæ‰‹å·¥æµ‹é‡ï¼‰

åˆ†æå¯ä»¥å¾—å‡ºï¼Œæˆ‘ä»¬ç¨‹åºéœ€è¦ä¸‰ä¸ªéƒ¨åˆ†
1. æŒæœ‰çƒå°çš„å…¨éƒ¨ä¿¡æ¯ï¼Œç”¨å‡ ä½•å…³ç³»è®¡ç®—ç„å‡†ä½ç½®
2. æˆªå›¾ã€é¼ æ ‡ã€é”®ç›˜æ“ä½œéƒ¨åˆ†ï¼Œä¸Win32APIç›¸å…³
3. æ ¹æ®æˆªå›¾æ¥è¯†åˆ«çƒçš„ä½ç½®ï¼Œå³OpenCVå¤„ç†éƒ¨åˆ†

é¦–å…ˆåœ¨ç›®å½•ä¸‹åˆ›å»ºå¦‚ä¸‹æ–‡ä»¶
```tree
.
â”œâ”€â”€ Application.cpp
â”œâ”€â”€ Application.hpp
â”œâ”€â”€ BilliardHelper.cpp
â”œâ”€â”€ BilliardHelper.hpp
â”œâ”€â”€ CMakeLists.txt            (å·²ç»åˆ›å»º)
â”œâ”€â”€ ImageAnalyser.cpp
â”œâ”€â”€ ImageAnalyser.hpp
â”œâ”€â”€ main.cpp
â”œâ”€â”€ README.md
â””â”€â”€ Vector.hpp
```
å…¶ä¸­CMakeLists.txtä¸­æ·»åŠ å¦‚ä¸‹ä¿¡æ¯
```cmake
# ç®—æ³•éƒ¨åˆ†
add_library(BilliardHelper BilliardHelper.cpp ImageAnalyser.cpp)
target_include_directories(BilliardHelper PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
target_link_libraries(BilliardHelper PRIVATE opencv_core opencv_imgcodecs)

# ä¸»ç¨‹åºéƒ¨åˆ†ï¼ŒWin32ç›¸å…³
add_executable(billiard_helper main.cpp Application.cpp)
target_link_libraries(billiard_helper PRIVATE BilliardHelper Winmm)
target_compile_definitions(billiard_helper PRIVATE UNICODE)
```
æ­¤æ—¶æˆ‘ä»¬çš„æ¶å­åŸºæœ¬å°±æ­å¥½äº†ï¼Œä¹‹åå°±æ˜¯åœ¨å„ä¸ªéƒ¨åˆ†å®ç°ä»£ç ã€‚

## BilliardHelper
åœ¨BilliardHelperä¸­æˆ‘ä»¬éœ€è¦å®ç°å¦‚ä¸‹åŠŸèƒ½
```cpp
// BilliardHlper.hpp
class BilliardHelper {
public:
    void UpdateBalls(const std::vector<Vec2>& ballsPosition);

    // Get the hitting point that can let the ball into the hole
    std::array<Vec2, 2> GetHittingPoint(const Vec2& cursor) const;
    // Get the hitting point that can let the ball pass the target point.
    std::array<Vec2, 2> GetHittingPoint(const Vec2& cursor, const Vec2& targetPoint) const;
};
```
å…¶ä¸­ç¬¬ä¸€ä¸ª`GetHittingPoint(...)`ç”¨äºå‡»çƒè¿›æ´åŠŸèƒ½ï¼Œç¬¬äºŒä¸ª`GetHittingPoint(...)`æ˜¯ç”¨äºä»¥çƒå‡»çƒåŠŸèƒ½ï¼Œå³è¿ç»­è°ƒç”¨æ­¤å‡½æ•°æ¥æ‰¾åˆ°æœ€ç»ˆçš„ç„å‡†ç‚¹ã€‚ä¸¤ä¸ªå‡½æ•°å‡è¿”å›ç„å‡†ç‚¹å’Œç›®æ ‡ç‚¹ã€‚ä»£ç å®ç°éƒ¨åˆ†å¦‚ä¸‹
```cpp
// BilliardHelper.cpp
std::array<Vec2, 2> BilliardHelper::GetHittingPoint(const Vec2& cursor) const {
    auto pow2 = [](double x) { return x * x; };
    auto ball = FindBall(cursor);

    // Find hole
    size_t targetHole   = 0;
    double minDistance2 = std::numeric_limits<double>::max();
    for (size_t i = 0; i < m_Holes.size(); i++) {
        Vec2 a = m_Holes[i] - ball, b = cursor - ball;
        if (dot(a, b) > 0) continue;
        double distance2 = dot(b, b) - pow2(dot(a, b) / a.norm());
        if (distance2 < minDistance2) {
            minDistance2 = distance2;
            targetHole   = i;
        }
    }

    return GetHittingPoint(cursor, m_Holes[targetHole]);
}
```
åŸºæœ¬æ€æƒ³ä¸ºï¼Œæ‰¾åˆ°é¼ æ ‡æœ€è¿‘çš„å½©çƒï¼Œè¿™ä¸ªå°±æ˜¯æˆ‘ä»¬æƒ³è¦å‡»æ‰“çš„çƒï¼Œç„¶åæ ¹æ®é¼ æ ‡ä½ç½®æ¥åˆ¤æ–­æˆ‘ä»¬æ­¤æ—¶æƒ³è¦æ‰“çš„æ˜¯å“ªä¸ªæ´ã€‚å…³é”®åœ¨äºå¦‚ä½•æ‰¾åˆ°æˆ‘ä»¬æƒ³è¦æ‰“çš„æ´ã€‚ç¤ºæ„å›¾å¦‚ä¸‹
{% asset_img find_hole.png%}
ç”±äºæˆ‘ä»¬é¼ æ ‡ä½ç½®æŒ‡æ˜æƒ³è¦æ‰“çš„æ´ï¼Œé‚£ä¹ˆé¼ æ ‡åº”è¯¥ä¸å½©çƒå’Œæ´æ‰€è¿ç›´çº¿æœ€è¿‘ï¼Œå¦‚å›¾ä¸­L2ç™½çº¿æœ€çŸ­ã€‚åŒæ—¶é¼ æ ‡ä¸å½©çƒè¿çº¿ä¸å½©çƒå’Œæ´æ‰€è¿ç›´çº¿å¤¹è§’å¤§äº90åº¦ï¼ˆä¿è¯äº†æ–¹å‘ï¼‰ä¹Ÿå°±æ˜¯å†…ç§¯è¦å°äº0ï¼Œå¦‚å›¾ä¸­ç²‰çº¿ä¸ç°çº¿å¤¹è§’ã€‚ä¹‹åå†è°ƒç”¨ç¬¬äºŒä¸ªå‡½æ•°`GetHittingPoint(...)`å³å¯ã€‚

ç¬¬äºŒä¸ªå‡½æ•°æ¯”è¾ƒç®€å•ï¼Œå¯è‡ªè¡ŒæŸ¥çœ‹æºç ã€‚

## Application
`Application.{hpp,cpp}`ä¸»è¦ç”¨Win32APIæ¥æ“ä½œç³»ç»Ÿç›¸å…³éƒ¨åˆ†ï¼Œå¦‚è·å–æ¡Œçƒçƒå°çš„æˆªå›¾ï¼Œè·å–é¼ æ ‡ä½ç½®ï¼Œè®¾ç½®é¼ æ ‡ä½ç½®ï¼Œè®¾ç½®åŠŸèƒ½çƒ­é”®ï¼Œæ­¤å¤„çš„éš¾ç‚¹åœ¨äºè·å–æ¡Œçƒçƒå°çš„çª—å£å¥æŸ„hWndï¼Œæ–¹æ³•å¦‚ä¸‹
```cpp
// Application.cpp
HWND Application::GetDeskWindow() const {
    auto result = FindWindowEx(nullptr, nullptr, L"#32770", nullptr);
    RECT rc;
    GetClientRect(result, &rc);
    return rc.right > 1000 ? result : nullptr;
}
```
å…¶ä¸­`#32770`ä¸ºæ¡Œçƒçƒå°çš„`WindowClass`ã€‚æ‰¾è¿™ä¸ªå€¼æ‰¾åˆ°å¿ƒç´¯ï¼Œå¤§æ¦‚æ­¥éª¤å°±æ˜¯
1. ç¼–å†™ä¸€ä¸ªè·å–å½“å‰é¼ æ ‡æŒ‡å‘çª—å£å¥æŸ„çš„å‡½æ•°
2. å‘ç°çƒå°çš„çª—å£æ²¡æœ‰æ ‡é¢˜ï¼Œæ‰€ä»¥ä»»åŠ¡ç®¡ç†å™¨ä¸­é‚£ä¸ªæ¡Œçƒè¿›ç¨‹çš„çª—å£ä¸æ˜¯å®é™…çƒå°çš„çª—å£ï¼Œå› æ­¤æ— æ³•åˆ©ç”¨çª—å£æ ‡é¢˜æ¥è·å–å¥æŸ„
3. ä½†çƒå°æœ‰`WindowClass`ï¼Œå®ƒçš„å€¼æ˜¯`#32770`ï¼Œä½†å¦‚æœåœ¨æ‰“å¼€è¿‡æ¡Œçƒè®¾ç½®é¡µé¢ï¼Œä¸”æ²¡é€€å‡ºè¿‡æ¸¸æˆæ—¶ï¼Œé€šè¿‡`WindowClass`æ¥è·å–å¥æŸ„ï¼Œå¾—åˆ°çš„æ—¶è®¾ç½®é¡µé¢çª—å£çš„å¥æŸ„ï¼Œå› æ­¤åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ä¸èƒ½æ‰“å¼€è®¾ç½®é¡µé¢ã€‚è¦è®¾ç½®ï¼Œä¹Ÿåªèƒ½è®¾ç½®å®Œæˆåå†é‡æ–°è¿›å…¥æˆ¿é—´ã€‚
4. æ ¹æ®æ‰€å¾—çª—å£å¥æŸ„ï¼Œè·å–å®ƒçš„å¤§å°ï¼Œå¦‚æœå°äºå®½åº¦1000è¯´æ˜ä¸æ˜¯æ¡Œçƒçƒå°ã€‚
å…¶å®ä¹Ÿå¯ä»¥åˆ©ç”¨çƒ­é”®å’Œé¼ æ ‡é…åˆè¿›è¡Œè·å–çª—å£å¥æŸ„ã€‚


å¾—åˆ°äº†çª—å£å¥æŸ„ï¼Œä¹Ÿå°±èƒ½è·å–çƒå°çš„æˆªå›¾ã€‚å°†è¿™äº›ä¿¡æ¯ç»™åˆ°OpenCVï¼Œå°±å¯ä»¥è¿›è¡Œè¯†åˆ«ä½ç½®ã€‚

è¿™é‡Œåˆ©ç”¨çƒ­é”®æ¥è¿›è¡Œç„å‡†åŠŸèƒ½è§¦å‘ï¼Œå…·ä½“åšæ³•æ˜¯
1. ç”¨Win32APIæ³¨å†Œçƒ­é”®
2. çƒ­é”®è§¦å‘æ—¶ï¼Œè°ƒç”¨æˆ‘ä»¬çš„å¤„ç†å‡½æ•°

```cpp
// Application.hpp
class Application{
    ...
    template <typename Func>
    Application& AddCallback(int hotKeyId, Func&& func) {
        m_CallBackFunc.emplace(hotKeyId, std::forward<Func>(func));
        return *this;
    }
    ...
    std::unordered_map<int, std::function<void()>> m_CallBackFunc;
    ...
};

// Application.cpp
...
LRESULT CALLBACK Application::WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
    ...
    switch (message) {
        case WM_HOTKEY: {
            if (pThis->IsBilliardRun()) {
                auto deskWindow = pThis->GetDeskWindow();
                pThis->UpdateCapture(deskWindow);
                RECT rc = {};
                GetWindowRect(deskWindow, &rc);
                SetWindowPos(hWnd, HWND_TOPMOST, rc.left, rc.top,
                             rc.right - rc.left, rc.bottom - rc.top, SWP_SHOWWINDOW);
                if (pThis->m_CallBackFunc.count(wParam) == 1) {
                    pThis->m_CallBackFunc.at(wParam)(); // Run callback function
                }
            }
        }
        ...
    }
    ...
}
```
è¿™æ ·å°±å¾ˆå®¹æ˜“åœ¨`main()`ä¸­æ³¨å†Œæˆ‘ä»¬çš„å›è°ƒå‡½æ•°ï¼Œå…·ä½“ç”¨æ³•å¦‚ä¸‹
```cpp
//main.cpp
app.AddCallback(1, [&]() -> void {
        // Function 1
   })
    .AddCallback(2, [&]() -> void {
        // Function 2
    });
```

## ImageAnalyser
æœ‰äº†æˆªå›¾æˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨OpenCVæ¥æ‹¿åˆ°çƒçš„åæ ‡ï¼Œé¦–å…ˆéœ€è¦å¯¹å›¾å½¢è¿›è¡Œé¢„å¤„ç†
```cpp
// ImageAnalyser.cpp
void ImageAnalyser::UpdateDesk(const std::vector<uint8_t>& desk) {
    if (desk.empty()) return;

    m_ImgMat = cv::imdecode(desk, cv::IMREAD_COLOR);
    if (!m_Gray.has_value()) m_Gray = cv::Mat{};

    auto& mat  = std::any_cast<cv::Mat&>(m_ImgMat);
    auto& gray = std::any_cast<cv::Mat&>(m_Gray);

    cv::Mat m1, m2;
    cv::cvtColor(mat, m1, cv::COLOR_BGR2HLS);
    cv::Scalar lower(49, 0, 0);
    cv::Scalar upperb(59, 255, 255);
    cv::inRange(m1, lower, upperb, gray);
}
```
è¿™é‡Œæˆ‘ä»¬åˆ©ç”¨çƒå°æ˜¯ç»¿è‰²çš„ï¼Œè¿›è¡Œé¢œè‰²è¿‡æ»¤ã€‚ç¬¬ä¸€æ­¥å°†é¢œè‰²ç©ºé—´è½¬ä¸ºHLSï¼Œè¿™ä¸ªæ›´ç©ºé—´æ–¹ä¾¿åšé¢œè‰²å¤„ç†ï¼Œç„¶åå®šçƒå°é¢œè‰²çš„ä¸Šä¸‹é™ï¼Œå…¶å®ƒåŒºåŸŸéƒ½ä¼šæ ‡è®°ä¸ºé»‘è‰²ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„çƒä¹Ÿå°±å˜æˆäº†é»‘çƒï¼Œè€Œçƒå°åˆ™å˜ä¸ºç™½è‰²ï¼Œå¦‚ä¸‹å›¾
{% asset_img test2.bmp%}
ä¹‹åå°±å¯ä»¥å¯¹çƒè¿›è¡Œè¯†åˆ«
```cpp
// ImageAnalyser.cpp
    auto& mat  = std::any_cast<cv::Mat&>(m_ImgMat);
    auto& gray = std::any_cast<cv::Mat&>(m_Gray);

    std::vector<cv::Vec3f> circles;
    cv::HoughCircles(gray, circles, cv::HOUGH_GRADIENT, 1,
                     20,              // change this value to detect circles with different distances to each other
                     100, 14, 13, 13  // change the last two parameters
                                      // (min_radius & max_radius) to detect larger circles
    );

    auto pow2 = [](auto x) { return x * x; };

    std::vector<Vec2> balls;
    balls.reserve(circles.size());
    Vec2 cueBall = {-1, -1};
    for (size_t i = 0; i < circles.size(); i++) {
        auto     center = Vec2{circles[i][0] + 0.5, circles[i][1] + 0.5};
        cv::Rect rect(center.x - 9, center.y - 9, 18, 18);
        auto     color    = cv::mean(mat(rect));
        auto     distance = std::sqrt(pow2(200 - color[0]) + pow2(200 - color[1]) + pow2(200 - color[2]));
        if (distance < 50) {
            cueBall = center;
        } else
            balls.emplace_back(center);
    }
    if (cueBall)
        balls.emplace_back(cueBall);

    return balls;
```
è¿™é‡Œæœ‰å››ä¸ªå…³é”®ç‚¹
1. æ–¯è¯ºå…‹çš„çƒåŠå¾„ä¸º13ä¸ªåƒç´ 
2. HoughCirclesçš„ä¸¤ä¸ªå‚æ•°æ˜¯äºŒåˆ†æ³•è°ƒè¯•å‡ºæ¥çš„
3. å¾—åˆ°çƒçš„ä¸­å¿ƒåæ ‡ç•¥å¾®åå·¦ä¸Šè§’ï¼Œæ‰‹åŠ¨å¯¹xyåˆ†é‡åŠ 0.5
4. å¾—åˆ°çƒçš„åæ ‡ï¼Œè¿”å›åˆ°å½©è‰²å›¾ä¸Šå¾—åˆ°çƒçš„é¢œè‰²ï¼Œå¹¶è®¡ç®—ä¸ç™½è‰²çš„é¢œè‰²è·ç¦»ï¼Œè·ç¦»æœ€è¿‘çš„ä¸ºç™½çƒ

## æ§åˆ¶é€»è¾‘éƒ¨åˆ†
æœ‰äº†è¿™äº›ä¿¡æ¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥åœ¨`main()`ï¼Œç¼–å†™æˆ‘ä»¬çš„é€»è¾‘
```cpp
// main.cpp
int CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    Application app;
    if (int ret = app.Initialize(); ret != 0) return 1;

    auto&          anaylser = ImageAnalyser::Get();
    BilliardHelper helper;

    app.AddCallback(1, [&]() -> void {
           anaylser.UpdateDesk(app.GetDeskImage());
           helper.UpdateBalls(anaylser.GetBallsPosition());

           auto [hitpoint, target] = helper.GetHittingPoint(app.GetCursor());
           app.MoveCursor(hitpoint).DrawLine(hitpoint, target);
       })
        .AddCallback(2, [&]() -> void {
            anaylser.UpdateDesk(app.GetDeskImage());
            helper.UpdateBalls(anaylser.GetBallsPosition());

            auto hintpoints = helper.GetReflectionPath(app.GetCursor(), 4);
            app.DrawLines(hintpoints);
        });

    while (!app.Quit()) {
        app.Tick();
    }
    return 0;
}
```
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œç”¨`WinMain`æ›¿æ¢äº†`main()`ï¼ŒåŒæ—¶åœ¨`CMakeLists.txt`ä¸­çš„`add_executable()`ä¸­æ·»åŠ `WIN32`å­—æ®µã€‚è¿™ä¸ªåšæ³•æ˜¯éšè—æ§åˆ¶çª—å£ï¼Œç›´æ¥è¿è¡Œç¨‹åºï¼Œä½†æ— æ³•åœ¨VScodeä¸­è¿›è¡Œè°ƒè¯•ã€‚éœ€è¦è°ƒè¯•çš„è¯å¯ä»¥æ”¹å›å»ã€‚